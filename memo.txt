ce qu'il se passe :
SQuery-To-SQL.ps1 --> interface graphique
    |--> SQuery-SQL-Translator.psm1 --> recupère URL parse squery, queryrootEntityType et QueryRoot
        |--> Lexer.ps1  --> tokenise la squery (c'est une classe, pas une fonction).
    |--> Squery-SQL-Translator.psm1 --> on a l'url Ou chaque Token est un objet avec des informations sur ces tokens (Operateur, identifier, boolean...)
        |--> Parser.ps1 --> parcour les token, regroupes ces token en fonction des fonctions principales 'join' 'top' 'where' 'select' 'order', avec pour certains eux memes des objets dedans (notamment le Where)
    |--> Squery-SQL-Translator.psm1 --> on a la liste des elements de l'URL regroupé par mots clef.
        |--> Validator.ps1 --> Outil de sécurité pour juger que l'URL fournit ne sort pas des normes (Where trop long, TOP trop grand etc..), check database-mapping.json
    |--> Squery-SQL-Translator.psm1 --> la query SQL qu'on va généré dans le futur "certifié" d'être valide 
        |--> Transformer.ps1 --> Transformer() -> utilise les json dans Configs pour faire la traduction avec les tokens.
        |--> Transformer.ps1 --> Build() -> assemble toutes les traductions faites pour former la requete SQL
    |--> Squery-SQL-Translator.psm1 --> print la query et remonte les warnings si il y en a

pour moi :
voir si je peux pas faire un export du swagger, pour lister les EntityTypes natifs, leur propriétés. surement utiles pour les méthodes GET, et POST/DELETE dans le futur

comme ça je peux faire      - export complet de la DB 
                            - export complet du swagger
                            faire le lien entre eux et tout garder localement.