# WorkspaceInitializer.ps1
# Provides Initialize-Workspace and Update-SQueryEntityTypes cmdlets.
# These guide the user through first-time setup and EntityType import.

# ---------------------------------------------------------------------------
# Private helpers (not exported)
# ---------------------------------------------------------------------------

# Base-32 encoding for Resource column names: alphabet 0-9, A-V
function ConvertTo-RCColumnName {
    param([int]$Index)
    $alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUV'
    if ($Index -eq 0) { return 'C0' }
    $result = ''
    $n = $Index
    while ($n -gt 0) {
        $result = $alphabet[$n % 32].ToString() + $result
        $n = [int][Math]::Floor($n / 32)
    }
    return 'C' + $result
}

# Parse EntityType XML and return an ordered hashtable of entityName -> config
function Read-EntityTypesFromXml {
    param([string]$XmlPath)

    $xmlContent = Get-Content $XmlPath -Raw -Encoding UTF8
    # Wrap in a root element if the file is raw EntityType fragments
    if ($xmlContent -notmatch '<\?xml') {
        $xmlContent = "<?xml version='1.0' encoding='utf-8'?><EntityTypes>$xmlContent</EntityTypes>"
    }
    try {
        [xml]$xml = $xmlContent
    } catch {
        throw "Failed to parse XML: $($_.Exception.Message)"
    }

    $result = [ordered]@{}
    foreach ($etNode in $xml.DocumentElement.SelectNodes('//EntityType')) {
        $entityName = $etNode.GetAttribute('Identifier')
        if ([string]::IsNullOrWhiteSpace($entityName)) { continue }

        # Derive alias from CamelCase initials (e.g. Directory_FR_User -> dfru)
        $words = [regex]::Matches($entityName, '[A-Z][a-z0-9_]*') | ForEach-Object { $_.Value }
        $alias = if ($words.Count -gt 1) {
            ($words | ForEach-Object { $_[0].ToString().ToLower() }) -join ''
        } else {
            $entityName.Substring(0, [Math]::Min(4, $entityName.Length)).ToLower()
        }

        $columns = [ordered]@{ Id = 'Id' }
        foreach ($propNode in $etNode.SelectNodes('Property')) {
            $propId    = $propNode.GetAttribute('Identifier')
            $propType  = $propNode.GetAttribute('Type')
            $targetIdx = $propNode.GetAttribute('TargetColumnIndex')
            if ([string]::IsNullOrWhiteSpace($propId) -or [string]::IsNullOrWhiteSpace($targetIdx)) { continue }

            $colName = ConvertTo-RCColumnName -Index ([int]$targetIdx)
            $columns[$propId] = $colName

            # ForeignKey properties also get a {Identifier}_Id alias
            if ($propType -eq 'ForeignKey') {
                $columns["${propId}_Id"] = $colName
            }
        }

        $result[$entityName] = [ordered]@{
            entityTypeId = 0
            alias        = $alias
            columns      = $columns
        }
    }
    return $result
}

# Write an entityTypes hashtable to resource-columns.json with UTF-8 BOM
function Write-ResourceColumnsJson {
    param([string]$OutputPath, [object]$EntityTypes)

    $outputObj = [ordered]@{
        '$schema'   = 'http://json-schema.org/draft-07/schema#'
        version     = '1.0'
        description = 'Resource EntityType column mappings generated by Initialize-Workspace / Update-SQueryEntityTypes.'
        entityTypes = [ordered]@{}
    }
    foreach ($en in ($EntityTypes.Keys | Sort-Object)) {
        $ec = $EntityTypes[$en]
        $colsOrdered = [ordered]@{}
        if ($ec.columns.Contains('Id')) { $colsOrdered['Id'] = 'Id' }
        foreach ($ck in ($ec.columns.Keys | Where-Object { $_ -ne 'Id' } | Sort-Object)) {
            $colsOrdered[$ck] = $ec.columns[$ck]
        }
        $outputObj.entityTypes[$en] = [ordered]@{
            entityTypeId = $ec.entityTypeId
            alias        = $ec.alias
            columns      = $colsOrdered
        }
    }

    $json = $outputObj | ConvertTo-Json -Depth 6
    $utf8Bom = [System.Text.UTF8Encoding]::new($true)
    [System.IO.File]::WriteAllText($OutputPath, $json, $utf8Bom)
}

# Load existing Custom/resource-columns.json into an ordered hashtable
function Read-ExistingResourceColumns {
    param([string]$FilePath)

    $existing = [ordered]@{}
    if (Test-Path $FilePath) {
        $json = Get-Content $FilePath -Raw | ConvertFrom-Json
        foreach ($en in $json.entityTypes.PSObject.Properties) {
            $cols = [ordered]@{}
            foreach ($cp in $en.Value.columns.PSObject.Properties) {
                $cols[$cp.Name] = $cp.Value
            }
            $existing[$en.Name] = [ordered]@{
                entityTypeId = [int]$en.Value.entityTypeId
                alias        = $en.Value.alias
                columns      = $cols
            }
        }
    }
    return $existing
}

# ---------------------------------------------------------------------------
# Public cmdlets
# ---------------------------------------------------------------------------

<#
.SYNOPSIS
Guided first-time setup for SQuery-SQL-Translator.

.DESCRIPTION
Interactive wizard that generates Configs/Custom/resource-columns.json from
an Identity Manager EntityType XML export. Run this once per project before
using Convert-SQueryToSql with Resource EntityTypes.

.PARAMETER XmlPath
Path to the EntityType XML export file. If omitted, the wizard prompts interactively.

.EXAMPLE
Initialize-Workspace
# Interactive: the wizard asks for the XML file path.

.EXAMPLE
Initialize-Workspace -XmlPath ".\entityTypes.xml"
# Non-interactive: generates resource-columns.json directly.
#>
function Initialize-Workspace {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$false)]
        [string]$XmlPath
    )

    $configRoot = Split-Path $script:DefaultConfigPath -Parent
    $customDir  = [System.IO.Path]::GetFullPath((Join-Path $configRoot 'Custom'))
    $outputPath = Join-Path $customDir 'resource-columns.json'
    $samplePath = [System.IO.Path]::GetFullPath((Join-Path $configRoot '..\SampleData\entityTypes_example.xml'))

    Write-Host ''
    Write-Host '========================================' -ForegroundColor Cyan
    Write-Host ' SQuery-SQL-Translator Workspace Setup' -ForegroundColor Cyan
    Write-Host '========================================' -ForegroundColor Cyan
    Write-Host ''

    # Already initialized?
    if (Test-Path $outputPath) {
        Write-Host 'Custom resource-columns.json already exists:' -ForegroundColor Yellow
        Write-Host "  $outputPath" -ForegroundColor Gray
        Write-Host ''
        Write-Host 'To add or update EntityTypes, use:' -ForegroundColor Gray
        Write-Host '  Update-SQueryEntityTypes -XmlPath <path> [-Merge]' -ForegroundColor White
        Write-Host ''
        return
    }

    Write-Host 'This wizard generates your project-specific EntityType column' -ForegroundColor Gray
    Write-Host 'mappings from an Identity Manager XML export.' -ForegroundColor Gray
    Write-Host ''
    Write-Host 'Output: ' -ForegroundColor Gray -NoNewline
    Write-Host $outputPath -ForegroundColor White
    Write-Host ''

    # Step 1: get the XML path
    Write-Host 'Step 1: Provide your EntityType XML export.' -ForegroundColor Cyan
    Write-Host '  Export from IM Admin Console: Administration > EntityTypes > Export' -ForegroundColor Gray
    if (Test-Path $samplePath) {
        Write-Host "  Format reference: $samplePath" -ForegroundColor Gray
    } else {
        Write-Host '  See SampleData\entityTypes_example.xml for the expected format.' -ForegroundColor Gray
    }
    Write-Host ''

    if ([string]::IsNullOrWhiteSpace($XmlPath)) {
        $XmlPath = (Read-Host '  Enter path to your EntityType XML file').Trim('" ')
    }

    if ([string]::IsNullOrWhiteSpace($XmlPath)) {
        Write-Host '  No file provided. Setup cancelled.' -ForegroundColor Yellow
        return
    }

    if (-not (Test-Path $XmlPath)) {
        Write-Host "  File not found: $XmlPath" -ForegroundColor Red
        return
    }

    # Step 2: parse and write
    Write-Host ''
    Write-Host 'Step 2: Importing EntityTypes...' -ForegroundColor Cyan
    Write-Host ''

    try {
        $entityTypes = Read-EntityTypesFromXml -XmlPath $XmlPath
    } catch {
        Write-Host "  Failed: $($_.Exception.Message)" -ForegroundColor Red
        return
    }

    if ($entityTypes.Count -eq 0) {
        Write-Host '  No EntityType elements found in the XML.' -ForegroundColor Yellow
        return
    }

    if (-not (Test-Path $customDir)) {
        New-Item -ItemType Directory -Path $customDir -Force | Out-Null
    }

    Write-ResourceColumnsJson -OutputPath $outputPath -EntityTypes $entityTypes

    foreach ($en in $entityTypes.Keys) {
        $colCount = $entityTypes[$en].columns.Count - 1
        Write-Host "  $en : $colCount columns (alias=$($entityTypes[$en].alias))" -ForegroundColor Gray
    }

    Write-Host ''
    Write-Host "Imported $($entityTypes.Count) EntityType(s)." -ForegroundColor Green
    Write-Host "Saved to: $outputPath" -ForegroundColor Green
    Write-Host ''
    Write-Host 'You are ready. Run Convert-SQueryToSql -Url <url> to start translating.' -ForegroundColor Cyan
    Write-Host ''
}

<#
.SYNOPSIS
Import or update Resource EntityType column mappings from XML.

.DESCRIPTION
Parses an Identity Manager EntityType XML export and writes (or merges into)
Configs/Custom/resource-columns.json. Use -Merge to add new EntityTypes
without replacing existing ones.

.PARAMETER XmlPath
Path to the EntityType XML export file.

.PARAMETER Merge
If specified, new EntityTypes are added to the existing Custom/resource-columns.json.
Existing EntityTypes with the same name are updated; others are preserved.

.EXAMPLE
Update-SQueryEntityTypes -XmlPath ".\new_export.xml"
# Replaces Custom/resource-columns.json entirely.

.EXAMPLE
Update-SQueryEntityTypes -XmlPath ".\additional_types.xml" -Merge
# Merges new EntityTypes into the existing file.
#>
function Update-SQueryEntityTypes {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true, Position=0)]
        [string]$XmlPath,

        [Parameter(Mandatory=$false)]
        [switch]$Merge
    )

    $configRoot = Split-Path $script:DefaultConfigPath -Parent
    $customDir  = [System.IO.Path]::GetFullPath((Join-Path $configRoot 'Custom'))
    $outputPath = Join-Path $customDir 'resource-columns.json'

    if (-not (Test-Path $XmlPath)) {
        Write-Error "File not found: $XmlPath"
        return
    }

    Write-Host 'Parsing EntityTypes...' -ForegroundColor Gray
    try {
        $newEntityTypes = Read-EntityTypesFromXml -XmlPath $XmlPath
    } catch {
        Write-Error "Failed to parse XML: $($_.Exception.Message)"
        return
    }

    if ($newEntityTypes.Count -eq 0) {
        Write-Host 'No EntityType elements found in the XML.' -ForegroundColor Yellow
        return
    }

    # Load existing if merging
    $final = [ordered]@{}
    if ($Merge) {
        $final = Read-ExistingResourceColumns -FilePath $outputPath
    }

    # Compute diff
    $added   = [System.Collections.ArrayList]::new()
    $updated = [System.Collections.ArrayList]::new()
    foreach ($en in $newEntityTypes.Keys) {
        if ($final.Contains($en)) { $null = $updated.Add($en) }
        else                         { $null = $added.Add($en)   }
        # Preserve custom alias if merging
        if ($Merge -and $final.Contains($en) -and $final[$en].alias) {
            $newEntityTypes[$en].alias = $final[$en].alias
        }
        $final[$en] = $newEntityTypes[$en]
    }

    if (-not (Test-Path $customDir)) {
        New-Item -ItemType Directory -Path $customDir -Force | Out-Null
    }

    Write-ResourceColumnsJson -OutputPath $outputPath -EntityTypes $final

    # Summary
    if ($added.Count -gt 0) {
        Write-Host "Added   ($($added.Count)): $($added.ToArray() -join ', ')" -ForegroundColor Green
    }
    if ($updated.Count -gt 0) {
        Write-Host "Updated ($($updated.Count)): $($updated.ToArray() -join ', ')" -ForegroundColor Yellow
    }
    $unchanged = $final.Count - $added.Count - $updated.Count
    if ($unchanged -gt 0) {
        Write-Host "Unchanged: $unchanged" -ForegroundColor Gray
    }
    Write-Host "Saved $($final.Count) total EntityType(s) to: $outputPath" -ForegroundColor Cyan
}
